#-------------------------------------------------------------
#                        HTML generation
#-------------------------------------------------------------

from parameters import *
from ast import *
from utils import *


#-------------------- types and utilities ----------------------

class Tag:
    def __init__(self, tag, idx, start=-1):
        self.tag = tag
        self.idx = idx
        self.start = start
    def __repr__(self):
        return "tag:" + str(self.tag) + ":" + str(self.idx)



# escape for HTML
def escape(s):
    s = s.replace('"', '&quot;')
    s = s.replace("'", '&#39;')
    s = s.replace("<", '&lt;')
    s = s.replace(">", '&gt;')
    return s



uid_count = -1
uid_hash = {}
def clear_uid():
    global uid_count, uid_hash
    uid_count = -1
    uid_hash = {}


def uid(node):
    if uid_hash.has_key(node):
        return uid_hash[node]

    global uid_count
    uid_count += 1
    uid_hash[node] = str(uid_count)
    return str(uid_count)



def line_id(lineno):
    return 'L' + str(lineno);


def qs(s):
    return "'" + s + "'"



#-------------------- main HTML generating function ------------------

def gen_html(text, changes, side):
    ltags = line_tags(text)
    ctags = change_tags(text, changes, side)
    ktags = keyword_tags(side)
    body = apply_tags(text, ltags + ctags + ktags, side)

    out = []
    out.append('<html>\n')
    out.append('<head>\n')
    out.append('<META http-equiv="Content-Type" content="text/html; charset=utf-8">\n')
    out.append('<LINK href="diff.css" rel="stylesheet" type="text/css">\n')
    out.append('<script type="text/javascript" src="nav.js"></script>\n')
    out.append('</head>\n')
    out.append('<body>\n')

    out.append('<pre>\n')
    out.append(body)
    out.append('</pre>\n')

    # out.append('</body>\n')
    # out.append('</html>\n')

    return ''.join(out)



# put the tags generated by change_tags into the text and create HTML
def apply_tags(s, tags, side):
    tags = sorted(tags, key = lambda t: (t.idx, -t.start))
    curr = 0
    out = []
    for t in tags:
        while curr < t.idx and curr < len(s):
            out.append(escape(s[curr]))
            curr += 1
        out.append(t.tag)

    while curr < len(s):
        out.append(escape(s[curr]))
        curr += 1
    return ''.join(out)




#--------------------- tag generation functions ----------------------

def change_tags(s, changes, side):
    tags = []
    for r in changes:
        key = r.orig if side == 'left' else r.cur
        if hasattr(key, 'lineno'):
            start = node_start(key)
            if isinstance(key, FunctionDef):
                end = start + len('def')
            elif isinstance(key, ClassDef):
                end = start + len('class')
            else:
                end = node_end(key)

            if r.orig <> None and r.cur <> None:
                # <a ...> for change and move
                tags.append(Tag(link_tag_start(r, side), start))
                tags.append(Tag("</a>", end, start))
            else:
                # <span ...> for deletion and insertion
                tags.append(Tag(span_start(r), start))
                tags.append(Tag('</span>', end, start))

    return tags



def line_tags(s):
    out = []
    lineno = 1;
    curr = 0
    while curr < len(s):
        if curr == 0 or s[curr-1] == '\n':
            out.append(Tag('<div class="line" id="L' + str(lineno) + '">', curr))
            out.append(Tag('<span class="lineno">' + str(lineno) + ' </span>', curr))
        if s[curr] == '\n':
            out.append(Tag('</div>', curr))
            lineno += 1
        curr += 1
    out.append(Tag('</div>', curr))
    return out



def keyword_tags(side):
    tags = []
    allNodes = allNodes1 if side == 'left' else allNodes2
    for node in allNodes:
        if type(node) in kwd_map:
            kw = kwd_map[type(node)]
            start = node_start(node)
            if src(node)[:len(kw)] == kw:
                startTag = (Tag('<span class="keyword">', start))
                tags.append(startTag)
                endTag = Tag('</span>', start + len(kw), start)
                tags.append(endTag)
    return tags


def span_start(diff):
    if diff.cur == None:
        cls = "deletion"
    else:
        cls = "insertion"
    text = escape(describe_change(diff))
    return '<span class="' + cls + '" title="' + text + '">'



def link_tag_start(diff, side):
    if side == 'left':
        me, other = diff.orig, diff.cur
    else:
        me, other = diff.cur, diff.orig

    text = escape(describe_change(diff))
    if diff.cost > 0:
        cls = "change"
    else:
        cls = "move"

    return ('<a id="' + uid(me) + '" '
            + ' class="' + cls + '" '
            + ' title="' + text + '" '
            + 'onclick="highlight('
                          + qs(uid(me)) + ","
                          + qs(uid(other)) + ","
                          + qs(line_id(me.lineno)) + ","
                          + qs(line_id(other.lineno)) + ')">')


kwd_map = {
    FunctionDef : 'def',
    ClassDef    : 'class',
    For         : 'for',
    While       : 'while',
    If          : 'if',
    With        : 'with',
    Return      : 'return',
    Yield       : 'yield',
    Global      : 'global',
    Raise       : 'raise',
    Pass        : 'pass',
    TryExcept   : 'try',
    TryFinally  : 'try',
    }




# human readable description of node

def describe_node(node):

    def code(s):
        return "'" + s + "'"

    def short(node):
        if isinstance(node, Module):
            ret = "module"
        elif isinstance(node, Import):
            ret = "import statement"
        elif isinstance(node, Name):
            ret = code(node.id)
        elif isinstance(node, Attribute):
            ret = code(short(node.value) + "." + short(node.attr_name))
        elif isinstance(node, FunctionDef):
            ret = "function " + code(node.name)
        elif isinstance(node, ClassDef):
            ret = "class " + code(node.name)
        elif isinstance(node, Call):
            ret = "call to " + code(short(node.func))
        elif isinstance(node, Assign):
            ret = "assignment"
        elif isinstance(node, If):
            ret = "if statement"
        elif isinstance(node, While):
            ret = "while loop"
        elif isinstance(node, For):
            ret = "for loop"
        elif isinstance(node, Yield):
            ret = "yield"
        elif isinstance(node, TryExcept) or isinstance(node, TryFinally):
            ret = "try statement"
        elif isinstance(node, Compare):
            ret = "comparison " + src(node)
        elif isinstance(node, Return):
            ret = "return " + short(node.value)
        elif isinstance(node, Print):
            ret = ("print " + short(node.dest) +
                   ", " if (node.dest!=None) else "" + print_list(node.values))
        elif isinstance(node, Expr):
            ret = "expression " + short(node.value)
        elif isinstance(node, Num):
            ret = str(node.n)
        elif isinstance(node, Str):
            if len(node.s) > 20:
                ret = "string " + code(node.s[:20]) + "..."
            else:
                ret = "string " + code(node.s)
        elif isinstance(node, Tuple):
            ret = "tuple (" + src(node) + ")"
        elif isinstance(node, BinOp):
            ret = (short(node.left) + " " +
                   node.opName.id + " " + short(node.right))
        elif isinstance(node, BoolOp):
            ret = src(node)
        elif isinstance(node, UnaryOp):
            ret = node.opName.id + " " + short(node.operand)
        elif isinstance(node, Pass):
            ret = "pass"
        elif isinstance(node, list):
            ret = map(short, node)
        else:
            ret = str(type(node))
        return ret

    ret = short(node)
    if hasattr(node, 'lineno'):
        ret = re.sub(" *(line [0-9]+)", '', ret)
        return ret + " (line " + str(node.lineno) + ")"
    else:
        return ret




# describe a change in a human readable fashion
def describe_change(diff):

    ratio = diff.similarity()
    sim = str(ratio)

    if ratio == 1.0:
        sim = " (unchanged)"
    else:
        sim = " (similarity %.1f%%)" % (ratio * 100)

    if diff.is_frame:
        wrap = "wrap "
    else:
        wrap = ""

    if diff.cur == None:
        ret = wrap + describe_node(diff.orig) + " deleted"
    elif diff.orig == None:
        ret = wrap + describe_node(diff.cur) + " inserted"
    elif node_name(diff.orig) <> node_name(diff.cur):
        ret = (describe_node(diff.orig) +
               " renamed to " + describe_node(diff.cur) + sim)
    elif diff.cost == 0 and diff.orig.lineno <> diff.cur.lineno:
        ret = (describe_node(diff.orig) +
               " moved to " + describe_node(diff.cur) + sim)
    elif diff.cost == 0:
        ret = describe_node(diff.orig) + " unchanged"
    else:
        ret = (describe_node(diff.orig) +
               " changed to " + describe_node(diff.cur) + sim)

    return ret

